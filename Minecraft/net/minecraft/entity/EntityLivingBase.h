#pragma once
#include "../item/ItemStack.h"
#include "../potion/PotionEffect.h"
#include "../util/CombatTracker.h"
#include "Entity.h"
#include "EnumCreatureAttribute.h"
#include "EnumHandSide.h"
#include "ai/attributes/AttributeModifier.h"

#include <DamageSource.h>
class IAttribute;
class AbstractAttributeMap;
class IAttributeInstance;
class EntityLivingBase : public Entity
{
  public:
    explicit EntityLivingBase(World *worldIn);
    void onKillCommand() override;
    bool canBreatheUnderwater();
    void onEntityUpdate() override;
    virtual bool isChild();
    pcg32 &getRNG();
    EntityLivingBase *getRevengeTarget() const;
    void setRevengeTarget(EntityLivingBase *livingBase);
    EntityLivingBase *getLastAttackedEntity() const;
    int32_t getLastAttackedEntityTime() const;
    void setLastAttackedEntity(Entity *entityIn);
    int32_t getIdleTime() const;
    void writeEntityToNBT(NBTTagCompound *compound) override;
    void readEntityFromNBT(NBTTagCompound *compound) override;
    static bool areAllPotionsAmbient(const std::vector<PotionEffect> &potionEffects);
    void clearActivePotions();
    std::vector<PotionEffect> getActivePotionEffects() const;
    std::unordered_map<Potion, PotionEffect> getActivePotionMap() const;
    bool isPotionActive(Potion potionIn) const;
    std::optional<PotionEffect> getActivePotionEffect(Potion potionIn);
    virtual void addPotionEffect(PotionEffect potioneffectIn);
    virtual bool isPotionApplicable(PotionEffect potioneffectIn);
    bool isEntityUndead();
    PotionEffect removeActivePotionEffect(Potion *potioneffectin);
    void removePotionEffect(Potion *potionIn);
    void heal(float healAmount);
    float getHealth();
    void setHealth(float health);
    bool attackEntityFrom(DamageSource::DamageSource source, float amount);
    DamageSource::DamageSource getLastDamageSource();
    void renderBrokenItemStack(const ItemStack &stack);
    virtual void onDeath(DamageSource::DamageSource cause);
    void knockBack(Entity *entityIn, float strength, double xRatio, double zRatio);
    virtual bool isOnLadder();
    bool isEntityAlive();
    void fall(float distance, float damageMultiplier) override;
    void performHurtAnimation() override;
    int32_t getTotalArmorValue();
    CombatTracker getCombatTracker() const;
    EntityLivingBase *getAttackingEntity();
    float getMaxHealth();
    int32_t getArrowCountInEntity();
    void setArrowCountInEntity(int32_t count);
    virtual void swingArm(EnumHand hand);
    void handleStatusUpdate(std::byte id) override;
    IAttributeInstance *getEntityAttribute(IAttribute *attribute);
    AbstractAttributeMap *getAttributeMap();
    virtual EnumCreatureAttribute getCreatureAttribute();
    ItemStack getHeldItemMainhand();
    ItemStack getHeldItemOffhand();
    ItemStack getHeldItem(EnumHand hand);
    void setHeldItem(EnumHand hand, ItemStack stack);
    bool hasItemInSlot(EntityEquipmentSlot p_190630_1_);
    virtual std::vector<ItemStack> &getArmorInventoryList()                   = 0;
    virtual ItemStack getItemStackFromSlot(EntityEquipmentSlot var1)          = 0;
    virtual void setItemStackToSlot(EntityEquipmentSlot var1, ItemStack var2) = 0;
    void setSprinting(bool sprinting) override;
    void dismountEntity(Entity *entityIn);
    bool getAlwaysRenderNameTagForRender() override;
    virtual void travel(float strafe, float vertical, float forward);
    float getAIMoveSpeed() const;
    virtual void setAIMoveSpeed(float speedIn);
    virtual bool attackEntityAsMob(Entity *entityIn);
    virtual bool isPlayerSleeping();
    void onUpdate() override;
    virtual void onLivingUpdate();
    void dismountRidingEntity() override;
    void updateRidden() override;
    void setPositionAndRotationDirect(double x, double y, double z, float yaw, float pitch,
                                      int32_t posRotationIncrements, bool teleport) override;
    void setJumping(bool jumping);
    virtual void onItemPickup(Entity *entityIn, int32_t quantity);
    bool canEntityBeSeen(Entity *entityIn);
    Vec3d getLook(float partialTicks) override;
    float getSwingProgress(float partialTickTime) const;
    bool isServerWorld() const;
    bool canBeCollidedWith() override;
    bool canBePushed() override;
    float getRotationYawHead() override;
    void setRotationYawHead(float rotation) override;
    void setRenderYawOffset(float offset) override;
    float getAbsorptionAmount() const;
    virtual void setAbsorptionAmount(float amount);
    virtual void sendEnterCombat();
    virtual void sendEndCombat();
    virtual EnumHandSide getPrimaryHand() = 0;
    bool isHandActive();
    EnumHand getActiveHand();
    void setActiveHand(EnumHand hand);
    void notifyDataManagerChange(DataParameter key) override;
    ItemStack getActiveItemStack() const;
    int32_t getItemInUseCount() const;
    int32_t getItemInUseMaxCount();
    void stopActiveHand();
    void resetActiveHand();
    bool isActiveItemStackBlocking();
    bool isElytraFlying();
    int32_t getTicksElytraFlying() const;
    bool attemptTeleport(double x, double y, double z);
    virtual bool canBeHitWithPotion();
    virtual bool attackable();
    void setPartying(BlockPos pos, bool isPartying);

    bool isSwingInProgress;
    EnumHand swingingHand;
    int32_t swingProgressInt;
    int32_t arrowHitTimer;
    int32_t hurtTime;
    int32_t maxHurtTime;
    float attackedAtYaw;
    int32_t deathTime;
    float prevSwingProgress;
    float swingProgress;
    float prevLimbSwingAmount;
    float limbSwingAmount;
    float limbSwing;
    int32_t maxHurtResistantTime;
    float prevCameraPitch;
    float cameraPitch;
    float randomUnused2;
    float randomUnused1;
    float renderYawOffset;
    float prevRenderYawOffset;
    float rotationYawHead;
    float prevRotationYawHead;
    float jumpMovementFactor;
    float moveStrafing;
    float moveVertical;
    float moveForward;
    float randomYawVelocity;

  protected:
    void entityInit() override;
    virtual void applyEntityAttributes();
    void updateFallState(double y, bool onGroundIn, IBlockState *state, const BlockPos &pos) override;
    virtual void frostWalk(const BlockPos &pos);
    virtual void onDeathUpdate();
    virtual bool canDropLoot();
    int32_t decreaseAirSupply(int32_t air);
    virtual int32_t getExperiencePoints(EntityPlayer *player);
    virtual bool isPlayer();
    void playEquipSound(ItemStack stack);
    void updatePotionEffects();
    virtual void updatePotionMetadata();
    void resetPotionEffectMetadata();
    virtual void onNewPotionEffect(PotionEffect id);
    virtual void onChangedPotionEffect(PotionEffect id, bool p_70695_2_);
    virtual void onFinishedPotionEffect(PotionEffect effect);
    virtual void blockUsingShield(EntityLivingBase *p_190629_1_);
    virtual void playHurtSound(DamageSource::DamageSource source);
    virtual void dropLoot(bool wasRecentlyHit, int32_t lootingModifier, DamageSource::DamageSource source);
    virtual void dropEquipment(bool wasRecentlyHit, int32_t lootingModifier);
    virtual SoundEvent getHurtSound(DamageSource::DamageSource damageSourceIn);
    virtual SoundEvent getDeathSound();
    virtual SoundEvent getFallSound(int32_t heightIn);
    virtual void dropFewItems(bool wasRecentlyHit, int32_t lootingModifier);
    virtual void damageArmor(float damage);
    virtual void damageShield(float damage);
    float applyArmorCalculations(DamageSource::DamageSource source, float damage);
    float applyPotionDamageCalculations(DamageSource::DamageSource source, float damage);
    virtual void damageEntity(DamageSource::DamageSource damageSrc, float damageAmount);
    void outOfWorld() override;
    void updateArmSwingProgress();
    virtual float getSoundVolume();
    float getSoundPitch();
    virtual bool isMovementBlocked();
    float getJumpUpwardsMotion();
    virtual void jump();
    void handleJumpWater();
    void handleJumpLava();
    float getWaterSlowDown();
    virtual float updateDistance(float p_110146_1_, float p_110146_2_);
    virtual void updateEntityActionState();
    virtual void collideWithNearbyEntities();
    virtual void collideWithEntity(Entity *entityIn);
    void markVelocityChanged() override;
    void markPotionsDirty();
    void updateActiveHand();
    void updateItemUse(ItemStack stack, int32_t eatingParticleCount);
    virtual void onItemUseFinish();

    static DataParameter HAND_STATES;
    int32_t ticksSinceLastSwing;
    EntityPlayer *attackingPlayer;
    int32_t recentlyHit;
    bool dead;
    int idleTime;
    float prevOnGroundSpeedFactor;
    float onGroundSpeedFactor;
    float movedDistance;
    float prevMovedDistance;
    float unused180;
    int32_t scoreValue;
    float lastDamage;
    bool isJumping;
    int32_t newPosRotationIncrements;
    double interpTargetX;
    double interpTargetY;
    double interpTargetZ;
    double interpTargetYaw;
    double interpTargetPitch;
    ItemStack activeItemStack;
    int32_t activeItemStackUseCount;
    int32_t ticksElytraFlying;

  private:
    bool checkTotemDeathProtection(DamageSource::DamageSource p_190628_1_);
    bool canBlockDamageSource(DamageSource::DamageSource damageSourceIn);
    bool canGoThroughtTrapDoorOnLadder(BlockPos pos, IBlockState *state);
    int32_t getArmSwingAnimationEnd();
    void updateElytra();

    static std::shared_ptr<spdlog::logger> LOGGER;
    static xg::Guid SPRINTING_SPEED_BOOST_ID;
    static AttributeModifier SPRINTING_SPEED_BOOST;
    static DataParameter HEALTH;
    static DataParameter POTION_EFFECTS;
    static DataParameter HIDE_PARTICLES;
    static DataParameter ARROW_COUNT_IN_ENTITY;
    AbstractAttributeMap *attributeMap;
    CombatTracker combatTracker;
    std::unordered_map<Potion, PotionEffect> activePotionsMap;
    std::vector<ItemStack> handInventory;
    std::vector<ItemStack> armorArray;
    bool potionsNeedUpdate;
    EntityLivingBase *revengeTarget;
    int32_t revengeTimer;
    EntityLivingBase *lastAttackedEntity;
    int32_t lastAttackedEntityTime;
    float landMovementFactor;
    int32_t jumpTicks;
    float absorptionAmount;
    BlockPos prevBlockpos;
    DamageSource::DamageSource lastDamageSource;
    int64_t lastDamageStamp;
};
